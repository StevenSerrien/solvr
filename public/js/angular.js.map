{"version":3,"sources":["annotated.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"angular.js","sourcesContent":["var dependencies = [\n  'sl.services',\n  'sl.directives',\n  'sl.controllers',\n\n  'angular-loading-bar',\n  'ngAnimate',\n  'uiGmapgoogle-maps',\n  'nemLogging',\n  'ngRoute',\n  'ngSanitize',\n  'angular.vertilize',\n  'ngMask',\n  'validation.match',\n  'ngLetterAvatar',\n  'mm.foundation',\n  'ngTouch',\n\n];\n\nvar sl = {\n  app: angular.module('sl', dependencies),\n  controllers: angular.module('sl.controllers', []),\n  directives: angular.module('sl.directives', []),\n  services: angular.module('sl.services', [])\n};\n\nsl.app.config([\"$locationProvider\", \"$interpolateProvider\", function($locationProvider, $interpolateProvider) {\n  var supports_history_api = function() {\n    return !!(window.history && history.pushState);\n  };\n\n  $interpolateProvider.startSymbol('##');\n  $interpolateProvider.endSymbol('##');\n    if (supports_history_api()) {\n      $locationProvider.html5Mode(true);\n    } else {\n      $locationProvider.html5Mode(false);\n    }\n}]);\n\nsl.directives.directive('slAutofill', function(){\n  return function(scope, elem, attrs) {\n\n      // Fix autofill issues where Angular doesn't know about autofilled inputs\n      if(attrs.ngSubmit) {\n        setTimeout(function() {\n          elem.unbind('submit').submit(function(e) {\n            e.preventDefault();\n            elem.find('input, textarea, select').trigger('input').trigger('change').trigger('keydown');\n            scope.$apply();\n          });\n        }, 0);\n      }\n    };\n})\n\nsl.directives.directive('profileInitial', ['$timeout', function($timeout) {\n    return {\n        restrict: 'A',\n        replace: true,\n        template: function (el, atts) {\n            var dataName =  atts.dataName;\n\n            return\n                \"<img data-name'\" + atts.dataName + \"' class='p-profile' />\";\n        },\n    };\n}]);\n\nsl.directives.directive('slPwCheck', function(){\n  return {\n      require: 'ngModel',\n      link: function (scope, elem, attrs, ctrl) {\n        var firstPassword = '#' + attrs.pwCheck;\n        elem.add(firstPassword).on('keyup', function () {\n          scope.$apply(function () {\n            var v = elem.val()===$(firstPassword).val();\n            ctrl.$setValidity('pwmatch', v);\n          });\n        });\n      }\n    }\n});\n\nsl.directives.directive('soDropdown', ['$timeout', function($timeout) {\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        replace: true,\n        transclude: true,\n        template: function (el, atts) {\n            var itemName = 'dropdownItem';\n            var valueField = itemName + '.' + (atts.valueField || 'id');\n            var textField = itemName + '.' + (atts.textField || 'name');\n            var localityField = itemName + '.' + (atts.textField || 'locality')\n            return \"<select class='ui search dropdown'>\" +\n                \"<div ng-transclude></div>\" +\n                \"   <option value='{{\" + valueField + \"}}' ng-repeat='\" + itemName + \" in \" + atts.dropdownItems + \" track by \" + valueField + \"'>\" +\n                \"       {{\" + textField + \"}}\" +\n                \"  ( \" + \"{{\" + localityField + \"}}\" + \" )\"  +\n                \"   </option>\" +\n                \"</select>\";\n        },\n        link: function (scope, el, atts, ngModel) {\n            $(el).dropdown({\n                onChange: function (value, text, choice) {\n                    scope.$apply(function () {\n                        ngModel.$setViewValue(value);\n                        \n                    });\n                },\n                placeholder: atts.placeholder,\n            });\n            ngModel.$render = function () {\n                console.log('set value', el, ngModel, ngModel.$viewValue);\n                $timeout(function () {\n                    $(el).dropdown('set value', ngModel.$viewValue);\n                });\n                //$(el).dropdown('set value', ngModel.$viewValue);\n            };\n        }\n    };\n}]);\n\nsl.directives.directive('soDropdownMultiple', ['$timeout', function($timeout) {\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        replace: true,\n        transclude: true,\n        template: function (el, atts) {\n            var itemName = 'dropdownItem';\n            var valueField = itemName + '.' + (atts.valueField || 'id');\n            var textField = itemName + '.' + (atts.textField || 'name');\n            var localityField = itemName + '.' + (atts.textField || 'locality')\n            return \"<select class='ui fluid normal dropdown selection multiple' multiple=''>\" +\n                \"<div ng-transclude></div>\" +\n                \"   <option value='{{\" + valueField + \"}}' ng-repeat='\" + itemName + \" in \" + atts.dropdownItems + \" track by \" + valueField + \"'>\" +\n                \"       {{\" + textField + \"}}\" +\n                \"   </option>\" +\n                \"</select>\";\n        },\n        link: function (scope, el, atts, ngModel) {\n            $(el).dropdown({\n                // onChange: function (value, text, choice) {\n                //     scope.$apply(function () {\n                //         ngModel.$setViewValue(value);\n                //\n                //     });\n                // },\n                placeholder: atts.placeholder,\n            });\n            ngModel.$render = function () {\n                // console.log('set value', el, ngModel, ngModel.$viewValue);\n                $timeout(function () {\n                    $(el).dropdown('set value', ngModel.$viewValue);\n                });\n                // $(el).dropdown('set value', ngModel.$viewValue);\n            };\n        }\n    };\n}]);\n\nsl.directives.directive('soDropdownMultipleNolabel', ['$timeout', function($timeout) {\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        replace: true,\n        transclude: true,\n        template: function (el, atts) {\n            var itemName = 'dropdownItem';\n            var valueField = itemName + '.' + (atts.valueField || 'id');\n            var textField = itemName + '.' + (atts.textField || 'name');\n            var localityField = itemName + '.' + (atts.textField || 'locality')\n            return \"<select class='ui fluid normal dropdown selection multiple' multiple=''>\" +\n                \"<div ng-transclude></div>\" +\n                \"   <option value='{{\" + valueField + \"}}' ng-repeat='\" + itemName + \" in \" + atts.dropdownItems + \" track by \" + valueField + \"'>\" +\n                \"       {{\" + textField + \"}}\" +\n                \"   </option>\" +\n                \"</select>\";\n        },\n        link: function (scope, el, atts, ngModel) {\n            $(el).dropdown({\n                // onChange: function (value, text, choice) {\n                //     scope.$apply(function () {\n                //         ngModel.$setViewValue(value);\n                //\n                //     });cst-dropdown ui fluid normal dropdown selection multiple\n                // },\n                placeholder: atts.placeholder,\n                useLabels: false,\n            });\n            ngModel.$render = function () {\n                console.log('set value', el, ngModel, ngModel.$viewValue);\n                $timeout(function () {\n                    $(el).dropdown('set value', ngModel.$viewValue);\n                });\n                // $(el).dropdown('set value', ngModel.$viewValue);\n            };\n        }\n    };\n}]);\n\nsl.services.service('service', [\"$http\", \"$q\", function($http, $q){\n  this.fetch = function(method, url, data) {\n    var _promise = $q.defer();\n    $http({\n      method: method,\n      url: url,\n      data: data,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(function(response) {\n      _promise.resolve(response.data);\n    }, function(error) {\n      _promise.reject(error);\n    });\n    return _promise.promise;\n  };\n\n  this.afetch = function(method, url, data) {\n    return $http({\n      method: method,\n      url: url,\n      data: data,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).success(function(response){\n      return response;\n    }).error(function(response){\n      return response.data;\n    });\n};\n\n  this.get = function(url) {\n    var data = {};\n    return this.fetch('GET', url, data);\n  };\n\n  this.post = function(url, data) {\n    return this.fetch('POST', url, data);\n  };\n  //\n  // this.apost = function(url, data) {\n  //   return this.afetch('POST', url, data);\n  // };\n}]);\n\nsl.controllers.controller('ContactSignupCtrl', [\"$scope\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $rootScope, $location, service, $window) {\n  var self = this;\n\n  var savePractitioner = '/logopedist/nieuw';\n  var checkIfPractitionerExistsUrl = '/logopedist/checkIfExists';\n  var checkIfPracticeExistsUrl = '/logopedist/praktijk/checkIfExists';\n  var allPracticesUrl = '/practices/get/all';\n  var getPracticeById = '/practices/get/with-id';\n\n  this.events = {\n\n    changeTemplate: function(index) {\n      self.state.currentTemplate = self.state.templates[index];\n\n    },\n\n    updateUserData: function(index) {\n\n\n      // User info\n      if (index == 0) {\n        self.state.loading = true;\n        self.handlers.checkExistingUserRecord();\n      }\n      // Choice of new practice or existing\n      if (index == 1) {\n        self.events.changeTemplate(index + 1);\n      }\n      // Registratiestap\n      if (index == 2) {\n        if (self.user.practiceStatus == 'new') {\n          self.state.loading = true;\n          self.state.datatosend.existingPractice = '';\n          self.handlers.checkExistingPracticeRecord();\n\n        }\n        else if (self.user.practiceStatus == 'existing') {\n          self.state.registerloading = true;\n          self.handlers.postUserDataToServer();\n        }\n\n      }\n\n\n    },\n    fillDropdownExistingPractices: function() {\n      self.handlers.getAllExistingPractices();\n    }\n  };\n\n  this.handlers = {\n    fillTemplates: function() {\n      self.state.templates = [\n        { name: 'state-1.html', url: 'assets/templates/contact/state-1.html', index: 0, stateClass: 'state-0'},\n        { name: 'state-2.html', url: 'assets/templates/contact/state-2.html', index: 1, stateClass: 'state-1'},\n        { name: 'state-3.html', url: 'assets/templates/contact/state-3.html', index: 2, stateClass: 'state-2'},\n        { name: 'state-4.html', url: 'assets/templates/contact/state-4.html', index: 3, stateClass: 'state-3'},\n      ]\n      self.state.currentTemplate = self.state.templates[0];\n    },\n    clearCurrentStorage: function() {\n      self.state.datatosend = '';\n      self.state.response = '';\n    },\n    postUserDataToServer: function() {\n      self.state.registerloading = false;\n      console.log(self.state.datatosend);\n      service.post(savePractitioner, self.state.datatosend).then(function successCallback(response) {\n        self.state.registerloading = false;\n        self.state.loading = false;\n        self.state.response = response;\n\n        if (self.state.response.status == 'success') {\n\n          self.handlers.clearCurrentStorage();\n          self.events.changeTemplate(self.state.currentTemplate.index + 1);\n        }\n\n\n      }, function errorCallback(response) {\n        self.state.registerloading = false;\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n      );\n\n    },\n    checkExistingUserRecord: function() {\n      service.post(checkIfPractitionerExistsUrl, self.state.datatosend.user).then(function successCallback(response) {\n        console.log(response);\n        self.state.loading = false;\n        self.state.response = response;\n        self.events.changeTemplate(self.state.currentTemplate.index + 1);\n\n      }, function errorCallback(response) {\n        console.log(response.data);\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n      );\n    },\n    checkExistingPracticeRecord: function() {\n      service.post(checkIfPracticeExistsUrl, self.state.datatosend.practice).then(function successCallback(response) {\n        self.state.loading = false;\n        self.state.response = response;\n\n        if (self.state.response.status == 'success') {\n          // Send all data to register Practitioner and practice\n          self.state.registerloading = true;\n          self.handlers.postUserDataToServer();\n        }\n\n      }, function errorCallback(response) {\n        console.log(response.data);\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n    );\n    },\n    getAllExistingPractices: function() {\n\n      service.get(allPracticesUrl).then(function successCallback(response) {\n        self.state.practicesFromDB = response;\n        // console.log(\"alles bestaand\");\n        // console.log(response);\n\n        // $scope.$digest();\n      }, function errorCallback(response) {\n\n      });\n    },\n    getPracticeById: function() {\n\n      service.post(getPracticeById, self.state.selectedPractice).then(function successCallback(response) {\n        if (response.length > 0) {\n          console.log(response);\n          self.state.datatosend.existingPractice = response[0];\n        }\n        // $scope.$digest();\n      }, function errorCallback(response) {\n\n      });\n    },\n\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n    self.handlers.fillTemplates();\n  });\n\n  this.state = {\n    datatosend: {\n      practice: {\n\n      },\n      user: {\n\n      },\n    },\n    practicesFromDB:  [],\n    selectedPractice: {\n      index: ''\n    },\n    // selectedId = 2,\n    registerloading: false,\n    loading: false,\n    response: {},\n\n    globalForm: {},\n    animationClass: 'in-and-out',\n\n    templates: [],\n    currentTemplate: ''\n  };\n\n  var placeSearch, autocomplete;\n  var componentForm = {\n    street_number: 'short_name',\n    route: 'long_name',\n    locality: 'long_name',\n    postal_code: 'short_name'\n  };\n\n\n  this.googleHandlers = {\n    initAutocomplete: function() {\n      // Create the autocomplete object, restricting the search to geographical\n      // location types.\n      autocomplete = new google.maps.places.Autocomplete(\n          /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),\n          {\n            types: ['geocode'],\n            componentRestrictions: {country: 'be'}//Belgium only\n        });\n\n      // When the user selects an address from the dropdown, populate the address\n      // fields in the form.\n      google.maps.event.addListener(autocomplete, 'place_changed', function(){\n        var place = autocomplete.getPlace();\n\n\n\n\n        // self.state.datatosend.practice.streetname.$apply();\n        // $scope.$apply( function() {\n        // Location info\n          for (var i = 0; i < place.address_components.length; i++) {\n            var addressType = place.address_components[i].types[0];\n            if (componentForm[addressType]) {\n              var val = place.address_components[i][componentForm[addressType]];\n              self.state.datatosend.practice[addressType] = val;\n            }\n          };\n          // Lat and long\n          self.state.datatosend.practice.lat = place.geometry.location.lat();\n          self.state.datatosend.practice.lng = place.geometry.location.lng();\n\n          $scope.$digest();\n      });\n    },\n  }\n}]);\n\nsl.controllers.controller('practiceContactController', [\"$scope\", \"$log\", \"$modal\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $log, $modal, $rootScope, $location, service, $window) {\n  var self = this;\n  var contactPracticeUrl = '/practice/contact';\n\n  this.events = {\n    init: function() {\n\n    },\n  };\n\n  this.handlers = {\n    sendContactForm: function(practice) {\n      // Fill in practice in self.state\n\n      self.state.loading = true;\n      self.state.datatosend.practice = practice;\n      service.post(contactPracticeUrl, self.state.datatosend).then(function successCallback(response) {\n\n        self.state.loading = false;\n        self.state.response = response;\n        if (self.state.response.status == 'success') {\n            self.state.datatosend.user = '';\n            self.state.datatosend.practice = '';\n        }\n\n      }, function errorCallback(response) {\n\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n      );\n    },\n  };\n\n  this.modalHandlers = {\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n\n  });\n\n  self.events.init();\n\n\n  this.state = {\n    datatosend: {\n      user: {\n\n      },\n      practice: {\n\n      },\n    },\n    loading: false,\n    practice: {\n\n    },\n    linkedPractitioners: [\n\n    ],\n    unconfirmedPractitioners: [\n\n    ],\n    selectedPractitioner: {\n\n    },\n    specialities: [],\n    selectedSpecialities: [],\n\n  };\n\n}]);\n\nsl.controllers.controller('practitionerDashboardController', [\"$scope\", \"$log\", \"$modal\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $log, $modal, $rootScope, $location, service, $window) {\n  var self = this;\n  var testRoute = '/logopedist/test';\n  var getAllPractitioners = '/practice/getallpractitioners';\n  var acceptPractitionerUrl = '/practitioner/acceptnew';\n  var denyPractitionerUrl = '/practitioner/denynew';\n  var getAllSpecialities = '/specialities/getall';\n  var getAllSpecialitiesForPractice = '/practice/getcurrentspecialities';\n  var updateSpecialitiesUrl = '/practice/updatespecialities';\n\n  this.events = {\n\n  };\n\n  this.handlers = {\n    initPracticeView: function() {\n      self.handlers.getAllPractitionersByPractice();\n    },\n\n    test: function() {\n      $('.p-profile').initial();\n    },\n\n    init: function(practitioner) {\n      self.handlers.getAllSpecialities();\n\n    },\n    refreshData: function() {\n      self.state.linkedPractitioners.length = 0;\n      self.state.unconfirmedPractitioners.length = 0;\n      self.handlers.getAllPractitionersByPractice();\n    },\n    getAllSpecialities: function() {\n      service.get(getAllSpecialities).then(function successCallback(response) {\n        // console.log(response);\n        self.state.specialities = response;\n      }, function errorCallback(response) {\n\n      });\n    },\n\n    getAllPractitionersByPractice: function() {\n      service.get(getAllPractitioners).then(function successCallback(response) {\n        // console.log(response);\n        self.state.practice = response[0];\n        console.log(self.state.practice);\n\n        // console.log(self.state.practice);\n        self.handlers.getSpecialitiesOfPractice();\n        angular.forEach(response[0].practitioners, function(value, index){\n\n          if (response[0].practitioners[index].isConfirmed == 0) {\n            self.state.unconfirmedPractitioners.push(response[0].practitioners[index]);\n          }\n          else {\n            self.state.linkedPractitioners.push(response[0].practitioners[index]);\n          }\n\n          // console.log(response[0].practitioners[index]);\n        });\n        // console.log(self.state.linkedPractitioners);\n        // console.log(self.state.unconfirmedPractitioners);\n\n\n      }, function errorCallback(response) {\n\n      });\n    },\n    acceptPractitioner: function(practitioner) {\n      service.post(acceptPractitionerUrl, practitioner).then(function successCallback(response) {\n        console.log(response);\n        self.handlers.refreshData();\n      }, function errorCallBack(response) {\n\n      })\n    },\n    denyPractitioner: function(practitioner) {\n      service.post(denyPractitionerUrl, practitioner).then(function successCallback(response) {\n        console.log(response);\n        self.handlers.refreshData();\n      }, function errorCallBack(response) {\n\n      });\n    },\n    updateSpecialities: function() {\n      service.post(updateSpecialitiesUrl, self.state.selectedSpecialities).then(function successCallback(response) {\n        // console.log(response);\n        console.log(self.state.selectedSpecialities);\n        // self.handlers.refreshData();\n      }, function errorCallBack(response) {\n\n      });\n      // console.log(self.state.selectedSpecialities);\n    },\n    getSpecialitiesOfPractice: function() {\n      service.post(getAllSpecialitiesForPractice, self.state.practice).then(function successCallback(response) {\n        // console.log('hallo');\n        // console.log(response);\n        angular.forEach(response, function(value, index){\n\n          self.state.selectedSpecialities.push(response[index].id);\n          // if (response[0].practitioners[index].isConfirmed == 0) {\n          //   self.state.unconfirmedPractitioners.push(response[0].practitioners[index]);\n          // }\n          // else {\n          //   self.state.linkedPractitioners.push(response[0].practitioners[index]);\n          // }\n\n          // console.log(response[0].practitioners[index]);\n        });\n        console.log('hier is em dan');\n        console.log(self.state.selectedSpecialities);\n\n        // self.handlers.refreshData();\n      }, function errorCallBack(response) {\n\n      });\n    }\n    // submit: function() {\n    //   service.post(testRoute, self.state.selectedPractice).then(function successCallback(response) {\n    //\n    //     // $scope.$digest();\n    //   }, function errorCallback(response) {\n    //\n    //   });\n    // },\n  };\n\n  this.modalHandlers = {\n    acceptPractitioner: function(practitioner, size, backdrop, itemCount, closeOnClick) {\n      self.state.selectedPractitioner = practitioner;\n      // console.log(\"oerezoddddon\");\n      // console.log(self.state.selectedPractitioner);\n      // console.log(practitioner);\n      var params = {\n        templateUrl: 'acceptPractitioner.html',\n        resolve: {\n          practitioner: function() {\n            return self.state.selectedPractitioner;\n          },\n        },\n\n        controller: function($scope, $modalInstance, practitioner) {\n          var modal = this;\n          $scope.practitioner = practitioner;\n\n\n\n          $scope.reposition = function() {\n            $modalInstance.reposition();\n          };\n\n          $scope.ok = function() {\n            $modalInstance.close($scope.practitioner);\n          };\n\n          $scope.cancel = function() {\n            $modalInstance.dismiss('cancel');\n          };\n\n          $scope.openNested = function() {\n            open();\n          };\n        }\n      };\n\n      if(angular.isDefined(closeOnClick)){\n        params.closeOnClick = closeOnClick;\n      }\n\n      if(angular.isDefined(size)){\n        params.size = size;\n      }\n\n      if(angular.isDefined(backdrop)){\n        params.backdrop = backdrop;\n      }\n\n      var modalInstance = $modal.open(params);\n\n      modalInstance.result.then(function(practitioner) {\n            self.handlers.acceptPractitioner(practitioner);\n            // console.log('correct gesloten' + practitioner.firstname);\n            // $log.info(practitioner.firstname);\n        }, function() {\n            $log.info('Modal dismissed at: ' + new Date());\n      });\n    },\n    denyPractitioner: function(practitioner, size, backdrop, itemCount, closeOnClick) {\n      self.state.selectedPractitioner = practitioner;\n\n      var params = {\n        templateUrl: 'denyPractitioner.html',\n        resolve: {\n          practitioner: function() {\n            return self.state.selectedPractitioner;\n          },\n        },\n        controller: function($scope, $modalInstance, practitioner) {\n          var modal = this;\n          $scope.practitioner = practitioner;\n\n\n\n          $scope.reposition = function() {\n            $modalInstance.reposition();\n          };\n\n          $scope.ok = function() {\n            $modalInstance.close($scope.practitioner);\n          };\n\n          $scope.cancel = function() {\n            $modalInstance.dismiss('cancel');\n          };\n\n          $scope.openNested = function() {\n            open();\n          };\n        }\n      };\n\n      var modalInstance = $modal.open(params);\n\n      modalInstance.result.then(function(practitioner) {\n            self.handlers.denyPractitioner(practitioner);\n            // console.log('correct gesloten' + practitioner.firstname);\n            // $log.info(practitioner.firstname);\n        }, function() {\n            $log.info('Modal dismissed at: ' + new Date());\n      });\n    },\n  }\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n\n  });\n\n  self.handlers.init();\n\n\n  this.state = {\n    practice: {\n\n    },\n    linkedPractitioners: [\n\n    ],\n    unconfirmedPractitioners: [\n\n    ],\n    selectedPractitioner: {\n\n    },\n    specialities: [],\n    selectedSpecialities: [],\n\n  };\n\n}]);\n\nsl.controllers.controller('SearchCtrl', [\"$scope\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $rootScope, $location, service, $window) {\n  var self = this;\n\n  var allPracticesUrl = '/practices/get/all';\n  var getAllSpecialities = '/specialities/getall';\n  var allPracticesWithSelectedpecialitiesUrl = '/practices/get/all-w-specialities';\n\n  $scope.$watch(function() {\n\n  }, function(nv, ov) {\n    self.handlers.getAllExistingPractices();\n  }, true);\n\n  this.events = {\n    init: function() {\n      // self.handlers.getAllExistingPractices();\n      self.handlers.getAllSpecialities();\n    },\n  };\n\n  this.handlers = {\n    getAllExistingPractices: function() {\n\n      service.get(allPracticesUrl).then(function successCallback(response) {\n\n        self.state.practiceFromDB = response;\n        console.log(self.state.practiceFromDB);\n        angular.forEach(self.state.practiceFromDB, function(value, index){\n\n          self.state.practiceFromDB[index].coords = {};\n          self.state.practiceFromDB[index].coords.latitude = self.state.practiceFromDB[index].lat;\n          self.state.practiceFromDB[index].coords.longitude = self.state.practiceFromDB[index].lng;\n\n          self.state.practiceFromDB[index].latitude = self.state.practiceFromDB[index].lat;\n          self.state.practiceFromDB[index].longitude = self.state.practiceFromDB[index].lng;\n\n          self.state.practiceFromDB[index].show = false;\n\n          self.state.practiceFromDB[index].templateUrl = 'markerWindow.html';\n\n          // Push into readable array for Google Angular maps\n          self.state.practices.push(self.state.practiceFromDB[index]);\n\n          if (index == 0) {\n            self.state.map.center = self.state.practiceFromDB[index].coords;\n          }\n\n        });\n\n        // console.log(self.state.practices);\n\n        // angular.forEach(self.state.practices, function(value, index){\n        //\n        //   self.state.practices[index].coords =  {};\n        //\n        //   self.state.practices[index].coords.latitude = self.state.practiceFromDB);\n        //   self.state.practices[index].coords.longitude = parseInt(self.state.practices[index].lng);\n        //   // console.log(self.state.practices[index]);\n        //\n        // });\n        // self.state.map.center = self.state.practices[0].coords;\n        // console.log(self.state.practices[index]);\n\n      }, function errorCallback(response) {\n\n      });\n    },\n    getAllPracticesBySpecialities: function() {\n      service.post(allPracticesWithSelectedpecialitiesUrl, self.state.datatosend).then(function successCallback(response) {\n          self.state.practicesFromDBWS = response;\n          console.log(self.state.practicesFromDBWS);\n          self.state.practices.length = 0;\n          angular.forEach(self.state.practicesFromDBWS, function(value, index){\n            console.log('joski');\n\n            if (self.state.practicesFromDBWS[index].distance) {\n              self.state.practicesFromDBWS[index].distance = Math.round(self.state.practicesFromDBWS[index].distance / 100) / 10;\n            }\n\n            self.state.practicesFromDBWS[index].templateUrl = 'markerWindow.html';\n\n            self.state.practices.push(self.state.practicesFromDBWS[index]);\n\n            if (index == 0) {\n              self.state.map.center = self.state.practicesFromDBWS[index].coords;\n            }\n\n          });\n          // console.log(self.state.practices);\n\n      }, function errorCallBack(response) {\n\n      })\n    },\n    getAllSpecialities: function() {\n      service.get(getAllSpecialities).then(function successCallback(response) {\n        // console.log(response);\n        self.state.specialities = response;\n        // console.log(self.state.specialities);\n      }, function errorCallback(response) {\n\n      });\n    },\n  };\n\n  this.markerhandlers = {\n    onClick: function(marker, eventName, model) {\n    \n      model.show = !model.show;\n\n      console.log(model);\n      console.log('ons mdoemoe');\n    },\n    contact: function() {\n      console.log(self.state.practices);\n    },\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n\n  });\n\n  this.state = {\n    map: {\n      center: { latitude: '51', longitude: '4' },\n      zoom: 10,\n      events: {\n        zoom_changed: function () {\n          console.log('zoom_changed');\n\n        }\n      },\n      options: {\n        styles: [\n          {\n            \"featureType\": \"administrative\",\n            \"elementType\": \"labels.text.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#6195a0\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"landscape\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"color\": \"#f2f2f2\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"landscape\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#ffffff\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"poi\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"visibility\": \"off\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"poi.park\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#e6f3d6\"\n              },\n              {\n                \"visibility\": \"on\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"saturation\": -100\n              },\n              {\n                \"lightness\": 45\n              },\n              {\n                \"visibility\": \"simplified\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"visibility\": \"simplified\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#f4d2c5\"\n              },\n              {\n                \"visibility\": \"simplified\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"labels.text\",\n            \"stylers\": [\n              {\n                \"color\": \"#4e4e4e\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.arterial\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#f4f4f4\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.arterial\",\n            \"elementType\": \"labels.text.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#787878\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"road.arterial\",\n            \"elementType\": \"labels.icon\",\n            \"stylers\": [\n              {\n                \"visibility\": \"off\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"transit\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"visibility\": \"off\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"water\",\n            \"elementType\": \"all\",\n            \"stylers\": [\n              {\n                \"color\": \"#eaf6f8\"\n              },\n              {\n                \"visibility\": \"on\"\n              }\n            ]\n          },\n          {\n            \"featureType\": \"water\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [\n              {\n                \"color\": \"#eaf6f8\"\n              }\n            ]\n          }\n        ]\n      },\n    },\n    practices: [],\n    practiceFromDB: {},\n    practicesFromDBWS: {},\n    marker: {\n      options: {\n        animation: google.maps.Animation.DROP,\n        draggable: false,\n        icon: {\n          url: 'img/custom-marker-pre.png',\n          scaledSize: new google.maps.Size(60, 60),\n          anchor: new google.maps.Point(20,40),\n        },\n      },\n    },\n    specialities: [],\n    selectedSpecialities: [],\n    datatosend: {\n      address: {},\n      selectedSpecialities: [],\n    }\n  };\n\n  var placeSearch, autocomplete;\n  var componentForm = {\n    street_number: 'short_name',\n    route: 'long_name',\n    locality: 'long_name',\n    postal_code: 'short_name'\n  };\n\n\n  this.googleHandlers = {\n    initAutocomplete: function() {\n      // Create the autocomplete object, restricting the search to geographical\n      // location types.\n      autocomplete = new google.maps.places.Autocomplete(\n        /** @type {!HTMLInputElement} */(document.getElementById('autocomplete2')),\n        {\n          types: ['geocode'],\n          componentRestrictions: {country: 'be'}//Belgium only\n        });\n\n        // When the user selects an address from the dropdown, populate the address\n        // fields in the form.\n        google.maps.event.addListener(autocomplete, 'place_changed', function(){\n          var place = autocomplete.getPlace();\n\n\n\n\n          // self.state.datatosend.practice.streetname.$apply();\n          // $scope.$apply( function() {\n          // Location info\n          for (var i = 0; i < place.address_components.length; i++) {\n            var addressType = place.address_components[i].types[0];\n            if (componentForm[addressType]) {\n              var val = place.address_components[i][componentForm[addressType]];\n              self.state.datatosend.address[addressType] = val;\n            }\n          };\n          // Lat and long\n          self.state.datatosend.address.lat = place.geometry.location.lat();\n          self.state.datatosend.address.lng = place.geometry.location.lng();\n\n          $scope.$digest();\n        });\n      },\n    }\n  }]);\n\nsl.controllers.controller('TestCtrl', [\"$scope\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $rootScope, $location, service, $window) {\n  var self = this;\n\n\n  this.events = {\n\n  };\n\n  this.handlers = {\n\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n\n  });\n\n  this.state = {\n    test: 'ja hallo dag',\n  };\n\n}]);\n\nsl.controllers.controller('UserAuthCtrl', [\"$scope\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $rootScope, $location, service, $window) {\n  var self = this;\n\n\n  this.events = {\n\n  };\n\n  this.handlers = {\n\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n    \n  });\n\n  this.state = {\n    userRegister: {},\n  };\n\n}]);\n"]}