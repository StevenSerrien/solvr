{"version":3,"sources":["annotated.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"angular.js","sourcesContent":["var dependencies = [\n  'sl.services',\n  'sl.directives',\n  'sl.controllers',\n\n  'ngAnimate',\n  'ngRoute',\n  'ngSanitize',\n  'angular.vertilize',\n  'ngMask',\n  'validation.match'\n];\n\nvar sl = {\n  app: angular.module('sl', dependencies),\n  controllers: angular.module('sl.controllers', []),\n  directives: angular.module('sl.directives', []),\n  services: angular.module('sl.services', [])\n};\n\nsl.app.config([\"$locationProvider\", \"$interpolateProvider\", function($locationProvider, $interpolateProvider) {\n  var supports_history_api = function() {\n    return !!(window.history && history.pushState);\n  };\n\n  $interpolateProvider.startSymbol('##');\n  $interpolateProvider.endSymbol('##');\n    if (supports_history_api()) {\n      $locationProvider.html5Mode(true);\n    } else {\n      $locationProvider.html5Mode(false);\n    }\n}]);\n\nsl.directives.directive('slAutofill', function(){\n  return function(scope, elem, attrs) {\n\n      // Fix autofill issues where Angular doesn't know about autofilled inputs\n      if(attrs.ngSubmit) {\n        setTimeout(function() {\n          elem.unbind('submit').submit(function(e) {\n            e.preventDefault();\n            elem.find('input, textarea, select').trigger('input').trigger('change').trigger('keydown');\n            scope.$apply();\n          });\n        }, 0);\n      }\n    };\n})\n\nsl.directives.directive('slPwCheck', function(){\n  return {\n      require: 'ngModel',\n      link: function (scope, elem, attrs, ctrl) {\n        var firstPassword = '#' + attrs.pwCheck;\n        elem.add(firstPassword).on('keyup', function () {\n          scope.$apply(function () {\n            var v = elem.val()===$(firstPassword).val();\n            ctrl.$setValidity('pwmatch', v);\n          });\n        });\n      }\n    }\n});\n\nsl.directives.directive('soDropdown', ['$timeout', function($timeout) {\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        replace: true,\n        transclude: true,\n        template: function (el, atts) {\n            var itemName = 'dropdownItem';\n            var valueField = itemName + '.' + (atts.valueField || 'id');\n            var textField = itemName + '.' + (atts.textField || 'name');\n            var localityField = itemName + '.' + (atts.textField || 'locality')\n            return \"<select class='ui search dropdown'>\" +\n                \"<div ng-transclude></div>\" +\n                \"   <option value='{{\" + valueField + \"}}' ng-repeat='\" + itemName + \" in \" + atts.dropdownItems + \" track by \" + valueField + \"'>\" +\n                \"       {{\" + textField + \"}}\" +\n                \"  ( \" + \"{{\" + localityField + \"}}\" + \" )\"  +\n                \"   </option>\" +\n                \"</select>\";\n        },\n        link: function (scope, el, atts, ngModel) {\n            $(el).dropdown({\n                onChange: function (value, text, choice) {\n                    scope.$apply(function () {\n                        ngModel.$setViewValue(value);\n                        \n                    });\n                },\n                placeholder: atts.placeholder,\n            });\n            ngModel.$render = function () {\n                console.log('set value', el, ngModel, ngModel.$viewValue);\n                $timeout(function () {\n                    $(el).dropdown('set value', ngModel.$viewValue);\n                });\n                //$(el).dropdown('set value', ngModel.$viewValue);\n            };\n        }\n    };\n}]);\n\nsl.services.service('service', [\"$http\", \"$q\", function($http, $q){\n  this.fetch = function(method, url, data) {\n    var _promise = $q.defer();\n    $http({\n      method: method,\n      url: url,\n      data: data,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(function(response) {\n      _promise.resolve(response.data);\n    }, function(error) {\n      _promise.reject(error);\n    });\n    return _promise.promise;\n  };\n\n  this.afetch = function(method, url, data) {\n    return $http({\n      method: method,\n      url: url,\n      data: data,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).success(function(response){\n      return response;\n    }).error(function(response){\n      return response.data;\n    });\n};\n\n  this.get = function(url) {\n    var data = {};\n    return this.fetch('GET', url, data);\n  };\n\n  this.post = function(url, data) {\n    return this.fetch('POST', url, data);\n  };\n  //\n  // this.apost = function(url, data) {\n  //   return this.afetch('POST', url, data);\n  // };\n}]);\n\nsl.controllers.controller('ContactSignupCtrl', [\"$scope\", \"$rootScope\", \"$location\", \"service\", \"$window\", function($scope, $rootScope, $location, service, $window) {\n  var self = this;\n\n  var savePractitioner = '/logopedist/nieuw';\n  var checkIfPractitionerExistsUrl = '/logopedist/checkIfExists';\n  var checkIfPracticeExistsUrl = '/logopedist/praktijk/checkIfExists';\n  var allPracticesUrl = '/practices/get/all';\n  var getPracticeById = '/practices/get/with-id';\n\n  this.events = {\n\n    changeTemplate: function(index) {\n      self.state.currentTemplate = self.state.templates[index];\n\n    },\n\n    updateUserData: function(index) {\n\n\n      // User info\n      if (index == 0) {\n        self.state.loading = true;\n        self.handlers.checkExistingUserRecord();\n      }\n      // Choice of new practice or existing\n      if (index == 1) {\n        self.events.changeTemplate(index + 1);\n      }\n      // Registratiestap\n      if (index == 2) {\n        self.state.loading = true;\n        self.handlers.checkExistingPracticeRecord();\n      }\n\n\n    },\n    fillDropdownExistingPractices: function() {\n      self.handlers.getAllExistingPractices();\n    }\n  };\n\n  this.handlers = {\n    fillTemplates: function() {\n      self.state.templates = [\n        { name: 'state-1.html', url: 'assets/templates/contact/state-1.html', index: 0, stateClass: 'state-0'},\n        { name: 'state-2.html', url: 'assets/templates/contact/state-2.html', index: 1, stateClass: 'state-1'},\n        { name: 'state-3.html', url: 'assets/templates/contact/state-3.html', index: 2, stateClass: 'state-2'},\n        { name: 'state-4.html', url: 'assets/templates/contact/state-4.html', index: 3, stateClass: 'state-3'},\n      ]\n      self.state.currentTemplate = self.state.templates[0];\n    },\n    clearCurrentStorage: function() {\n      self.state.datatosend = '';\n      self.state.response = '';\n    },\n    postUserDataToServer: function() {\n      self.state.registerloading = false;\n      console.log(self.state.datatosend);\n      service.post(savePractitioner, self.state.datatosend).then(function successCallback(response) {\n        self.state.registerloading = false;\n        self.state.loading = false;\n        self.state.response = response;\n        if (self.state.response.status = 'success') {\n          self.handlers.clearCurrentStorage();\n          self.events.changeTemplate(self.state.currentTemplate.index + 1);\n        }\n      }, function errorCallback(response) {\n        self.state.registerloading = false;\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n      );\n\n    },\n    checkExistingUserRecord: function() {\n      service.post(checkIfPractitionerExistsUrl, self.state.datatosend.user).then(function successCallback(response) {\n        console.log(response);\n        self.state.loading = false;\n        self.state.response = response;\n        self.events.changeTemplate(self.state.currentTemplate.index + 1);\n\n      }, function errorCallback(response) {\n        console.log(response.data);\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n      );\n    },\n    checkExistingPracticeRecord: function() {\n      service.post(checkIfPracticeExistsUrl, self.state.datatosend.practice).then(function successCallback(response) {\n        self.state.loading = false;\n        self.state.response = response;\n\n        if (self.state.response.status == 'success') {\n          // Send all data to register Practitioner and practice\n          self.state.registerloading = true;\n          self.handlers.postUserDataToServer();\n        }\n\n      }, function errorCallback(response) {\n        console.log(response.data);\n        self.state.loading = false;\n        self.state.response = response.data;\n      }\n    );\n    },\n    getAllExistingPractices: function() {\n      console.log(self.state.practicesFromDB);\n      service.get(allPracticesUrl).then(function successCallback(response) {\n        self.state.practicesFromDB = response;\n\n        console.log(self.state.practicesFromDB);\n        // $scope.$digest();\n      }, function errorCallback(response) {\n\n      });\n    },\n    getPracticeById: function() {\n      console.log('ik probeer praktijk' + self.state.selectedPractice);\n      service.post(getPracticeById, self.state.selectedPractice).then(function successCallback(response) {\n        if (response.length > 0) {\n          console.log(response);\n          self.state.datatosend.existingPractice = response[0];\n        }\n\n\n        // $scope.$digest();\n      }, function errorCallback(response) {\n\n      });\n    },\n\n  };\n\n\n\n  // listeners\n  $rootScope.$on('$locationChangeSuccess', function() {\n    self.handlers.fillTemplates();\n  });\n\n  this.state = {\n    datatosend: {\n      practice: {\n\n      },\n      user: {\n\n      },\n    },\n    practicesFromDB:  [],\n    selectedPractice: {\n      index: ''\n    },\n    // selectedId = 2,\n    registerloading: false,\n    loading: false,\n    response: {},\n\n    globalForm: {},\n    animationClass: 'in-and-out',\n\n    templates: [],\n    currentTemplate: ''\n  };\n\n  var placeSearch, autocomplete;\n  var componentForm = {\n    street_number: 'short_name',\n    route: 'long_name',\n    locality: 'long_name',\n    postal_code: 'short_name'\n  };\n\n\n  this.googleHandlers = {\n    initAutocomplete: function() {\n      // Create the autocomplete object, restricting the search to geographical\n      // location types.\n      autocomplete = new google.maps.places.Autocomplete(\n          /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),\n          {\n            types: ['geocode'],\n            componentRestrictions: {country: 'be'}//Belgium only\n        });\n\n      // When the user selects an address from the dropdown, populate the address\n      // fields in the form.\n      google.maps.event.addListener(autocomplete, 'place_changed', function(){\n        var place = autocomplete.getPlace();\n\n\n\n\n        // self.state.datatosend.practice.streetname.$apply();\n        // $scope.$apply( function() {\n        // Location info\n          for (var i = 0; i < place.address_components.length; i++) {\n            var addressType = place.address_components[i].types[0];\n            if (componentForm[addressType]) {\n              var val = place.address_components[i][componentForm[addressType]];\n              self.state.datatosend.practice[addressType] = val;\n            }\n          };\n          // Lat and long\n          self.state.datatosend.practice.lat = place.geometry.location.lat();\n          self.state.datatosend.practice.lng = place.geometry.location.lng();\n\n          $scope.$digest();\n      });\n    },\n  }\n}]);\n"]}